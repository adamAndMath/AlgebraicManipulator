assume Rec(Func<List<Integer,Complex>,Complex> f, Complex i, Integer n)
    rec<j,r>(eval(f,j,r),i,n)=eval(f,n,rec<j,r>(eval(f,j,r),i,sub(n,1)));

assume RecIdentity(Func<List<Integer,Complex>,Complex> f, Complex i)
    rec<j,r>(eval(f,j,r),i,0)=i;

assume Sum(Func<List<Integer,Complex>,Complex> f, Integer a, Integer b)
    sum<i>(eval(f,i),a,b)=rec<i,r>(add(r,eval(f,sub(add(i,a),1))),0,add(sub(b,a),1));

assume Prod(Func<List<Integer,Complex>,Complex> f, Integer a, Integer b)
    prod<i>(eval(f,i),a,b)=rec<i,r>(mult(r,eval(f,sub(add(i,a),1))),1,add(sub(b,a),1));

/*induction RecInner(Func<List<Integer, Complex>, Complex> f, Complex i, Integer n) {
    base n=1 {
        let 2 rec<j,r>(eval(f,j,r),i,1);
        substitute Rec[0->1](f,i,1):1;
        substitute Sub.Inverse[0->1](1):1,2,2;
        substitute RecIdentity[0->1](f,i):1,2;
        substitute RecIdentity[1->0](func<j1,r1>(eval(f,add(j1,1),r1)),eval(f,1,i)):1;
        fromeval:1,0;
        substitute Sub.Inverse[1->0](1):1,2;
    } n+ {
        call x eval(func<j1,r1>(eval(f,add(j1,1),r1)),n,x);
        fromeval:0;
        substitute Sub.Add1[0->1](n,1):0,2,2;
        substitute Rec[1->0](f,i,add(n,1)):0;
        toeval(j1=j:[1,0],r1=r:[2]):1,2,0;
        substitute Rec[1->0](func<j1,r1>(eval(f,add(j1,1),r1)),eval(f,1,i),n):1;
    }
} result {
    rec<j,r>(eval(f,j,r),i,n)=rec<j,r>(eval(f,add(j,1),r),eval(f,1,i),sub(n,1))
}*/

work SumIdentity(Func<Integer, Complex> f, Integer a) {
    let 2 sum<i>(eval(f,i),a,sub(a,1));
    substitute Sum[0->1](f,a,sub(a,1)):1;
    rename i->j:1;
    toeval(j1=j:[1,1,0,0],r1=r:[0]):1,0;
    substitute Sub.Commute2[2->0](sub(a,1),1,a):1,2;
    substitute Sub.Add1[2->0](a,1):1,2,0;
    substitute Sub.Inverse[0->1](a):1,2;
    substitute RecIdentity[0->1](func<j1, r1>(add(r1,eval(f,sub(add(j1,a),1)))),0):1;
} result {
    sum<i>(eval(f,i),a,sub(a,1))=0
}

work ProdIdentity(Func<Integer, Complex> f, Integer a) {
    let 2 prod<i>(eval(f,i),a,sub(a,1));
    substitute Prod[0->1](f,a,sub(a,1)):1;
    rename i->j:1;
    toeval(j1=j:[1,1,0,0],r1=r:[0]):1,0;
    substitute Sub.Commute2[2->0](sub(a,1),1,a):1,2;
    substitute Sub.Add1[2->0](a,1):1,2,0;
    substitute Sub.Inverse[0->1](a):1,2;
    substitute RecIdentity[0->1](func<j1, r1>(mult(r1,eval(f,sub(add(j1,a),1)))),1):1;
} result {
    prod<i>(eval(f,i),a,sub(a,1))=1
}

work SumRec(Func<Integer, Complex> f, Integer a, Integer b) {
    let 2 sum<i>(eval(f,i),a,b);
    substitute Sum[0->1](f,a,b):1;
    toeval(i1=i:[1,1,0,0],r1=r:[0]):1,0;
    rename i->j:1;
    substitute Rec[0->1](func<i1,r1>(add(r1,eval(f,sub(add(i1,a),1)))),0,add(sub(b,a),1)):1;
    rename j->i:1,2;
    fromeval:1,2,0;
    fromeval:1;
    substitute Sub.Commute2[2->0](b,1,a):1,1,1,0,0;
    substitute Sub.Add1[2->0](add(b,1),a):1,1,1,0;
    substitute Sub.Add1[1->0](b,1):1,1,1;
    substitute Sub.Add1[1->2](sub(b,a),1):1,0,2;
    substitute Sub.Commute[0->1](b,a,1):1,0,2,0;
    substitute Sum[1->0](f,a,sub(b,1)):1,0;
} result {
    sum<i>(eval(f,i),a,b)=add(sum<i>(eval(f,i),a,sub(b,1)),eval(f,b))
}

work ProdRec(Func<Integer, Complex> f, Integer a, Integer b) {
    let 2 prod<i>(eval(f,i),a,b);
    substitute Prod[0->1](f,a,b):1;
    toeval(i1=i:[1,1,0,0],r1=r:[0]):1,0;
    rename i->j:1;
    substitute Rec[0->1](func<i1,r1>(mult(r1,eval(f,sub(add(i1,a),1)))),1,add(sub(b,a),1)):1;
    rename j->i:1,2;
    fromeval:1,2,0;
    fromeval:1;
    substitute Sub.Commute2[2->0](b,1,a):1,1,1,0,0;
    substitute Sub.Add1[2->0](add(b,1),a):1,1,1,0;
    substitute Sub.Add1[1->0](b,1):1,1,1;
    substitute Sub.Add1[1->2](sub(b,a),1):1,0,2;
    substitute Sub.Commute[0->1](b,a,1):1,0,2,0;
    substitute Prod[1->0](f,a,sub(b,1)):1,0;
} result {
    prod<i>(eval(f,i),a,b)=mult(prod<i>(eval(f,i),a,sub(b,1)),eval(f,b))
}

induction SumRec2(Func<Integer, Complex> f, Integer a, Integer b) {
    base b=a {
        let 2 sum<i>(eval(f,i),a,a);
        substitute SumRec[0->1](f,a,a):1;
        substitute SumIdentity[0->1](f,a):1,0;
        substitute Add.Commute[0->1](0,eval(f,a)):1;
        substitute SumIdentity[1->0](f,add(a,1)):1,1;
        substitute Sub.Add1[1->0](a,1):1,1,2;
    } b+ {
        substitute Sub.Add1[0->1](b,1):0,2;
        substitute Sub.Add1[0->1](b,1):1,1,2;
        call x add(x,eval(f,add(b,1)));
        substitute Add.Associate[0->1](eval(f,a),sum<i>(eval(f,i),add(a,1),sub(add(b,1),1)),eval(f,add(b,1))):1;
        substitute SumRec[1->0](f,a,add(b,1)):0;
        substitute SumRec[1->0](f,add(a,1),add(b,1)):1,1;
    } b- {
        substitute SumRec[0->1](f,a,b):0;
        substitute SumRec[0->1](f,add(a,1),b):1,1;
        substitute Add.Associate[1->0](eval(f,a),sum<i>(eval(f,i),add(a,1),sub(b,1)),eval(f,b)):1;
        call x sub(x,eval(f,b));
        substitute Sub.Add1[1->0](sum<i>(eval(f,i),a,sub(b,1)),eval(f,b)):0;
        substitute Sub.Add1[1->0](add(eval(f,a),sum<i>(eval(f,i),add(a,1),sub(b,1))),eval(f,b)):1;
    }
} result {
    sum<i>(eval(f,i),a,b)=add(eval(f,a),sum<i>(eval(f,i),add(a,1),b))
}

induction ProdRec2(Func<Integer, Complex> f, Integer a, Integer b) {
    base b=a {
        let 2 prod<i>(eval(f,i),a,a);
        substitute ProdRec[0->1](f,a,a):1;
        substitute ProdIdentity[0->1](f,a):1,0;
        substitute Mult.Commute[0->1](1,eval(f,a)):1;
        substitute ProdIdentity[1->0](f,add(a,1)):1,1;
        substitute Sub.Add1[1->0](a,1):1,1,2;
    } b+ {
        substitute Sub.Add1[0->1](b,1):0,2;
        substitute Sub.Add1[0->1](b,1):1,1,2;
        call x mult(x,eval(f,add(b,1)));
        substitute Mult.Associate[0->1](eval(f,a),prod<i>(eval(f,i),add(a,1),sub(add(b,1),1)),eval(f,add(b,1))):1;
        substitute ProdRec[1->0](f,a,add(b,1)):0;
        substitute ProdRec[1->0](f,add(a,1),add(b,1)):1,1;
    } b- {
        substitute ProdRec[0->1](f,a,b):0;
        substitute ProdRec[0->1](f,add(a,1),b):1,1;
        substitute Mult.Associate[1->0](eval(f,a),prod<i>(eval(f,i),add(a,1),sub(b,1)),eval(f,b)):1;
        call x div(x,eval(f,b));
        substitute Div.Mult1[1->0](prod<i>(eval(f,i),a,sub(b,1)),eval(f,b)):0;
        substitute Div.Mult1[1->0](mult(eval(f,a),prod<i>(eval(f,i),add(a,1),sub(b,1))),eval(f,b)):1;
    }
} result {
    prod<i>(eval(f,i),a,b)=mult(eval(f,a),prod<i>(eval(f,i),add(a,1),b))
}

/*induction SumAssociativeRange(Func<Integer, Complex> f, Integer a, Integer b, Integer c) {

} result {
    sum<i>(eval(f,i),a,c)=add(sum<i>(eval(f,i),a,sub(b,1)),sum<i>(
}*/

work SumIndexShift(Func<Integer, Complex> f, Integer a, Integer b, Integer c) {
    let 2 sum<i>(eval(f,i),a,b);
    substitute Sum[0->1](f,a,b):1;
    substitute Sub.Add1[0->1](b,c):1,2,0,0;
    substitute Sub.Commute[1->2](add(b,c),a,c):1,2,0;
    substitute Sub.Add1[0->1](sub(add(i,a),1),c):1,0,1,1;
    toeval(i1=add(sub(add(i,a),1),c):[1,0]):1,0,1;
    substitute Sub.Commute2[2->0](add(i,a),c,1):1,0,1,1;
    substitute Add.Associate[0->1](i,a,c):1,0,1,1,0;
    substitute Sum[1->0](func<i1>(eval(f, sub(i1,c))),add(a,c),add(b,c)):1;
    fromeval:1,0;
} result {
    sum<i>(eval(f,i),a,b)=sum<i>(eval(f,sub(i,c)),add(a,c),add(b,c))
}

work ProdIndexShift(Func<Integer, Complex> f, Integer a, Integer b, Integer c) {
    let 2 prod<i>(eval(f,i),a,b);
    substitute Prod[0->1](f,a,b):1;
    substitute Sub.Add1[0->1](b,c):1,2,0,0;
    substitute Sub.Commute[1->2](add(b,c),a,c):1,2,0;
    substitute Sub.Add1[0->1](sub(add(i,a),1),c):1,0,1,1;
    toeval(i1=add(sub(add(i,a),1),c):[1,0]):1,0,1;
    substitute Sub.Commute2[2->0](add(i,a),c,1):1,0,1,1;
    substitute Add.Associate[0->1](i,a,c):1,0,1,1,0;
    substitute Prod[1->0](func<i1>(eval(f, sub(i1,c))),add(a,c),add(b,c)):1;
    fromeval:1,0;
} result {
    prod<i>(eval(f,i),a,b)=prod<i>(eval(f,sub(i,c)),add(a,c),add(b,c))
}